# 1.9 정리

> ✏️ 지금까지 한 1장 내용을 돌이켜보면

1. 사용자 정보를 DB에 등록하거나 아이디로 조회하는 기능을 가진 DAO 코드를 생성
2. 해당 코드의 문제점을 살펴보고, 이를 다양한 패턴, 원칙, IoC/DI 프레임워크까지 적용해 개선

## 과정 정리

- 책임이 다른 코드를 분리, 두 개의 클래스로 만들었다(관심사의 분리, 리팩토링)
- 그 중에서 바뀔 수 있는 쪽의 클래스는 인터페이스를 구현하도록 하고, 다른 클래스에서
인터페이스를 통해서만 접근하도록 만들었다. 이렇게 함으로써 인터페이스를 정의한 쪽의
구현 방법이 달라져도 영향을 주지 않음(전략 패턴)
- 이를 통해 자신의 책임이 변경되는 경우 외에는 불필요한 변화가 발생하지 않도록
막고, 자신이 사용하는 외부 오브젝트의 기능은 자유롭게 확장하거나 변경할 수 있게 만듬(개방 폐쇄 원칙)
- 결국 한쪽의 기능 변화가 다른 쪽의 변경을 요하지 않아도 됬고(낮은 결합도), 자신의 책임과
관심사에만 순수하게 집중하는(높은 응집도) 깔끔한 코드 작성 가능하였다
- 오브젝트가 생성되고 여타 오브젝트와 관계를 맺는 작업의 제어권을 별도 오브젝트 팩토리에게
위임, 또는 오브젝트 팩토리의 기능을 일반화한 IoC 컨테이너로 넘겨서 오브젝트가 자신이 사용할
대상의 생성이나 선택에 관한 책임으로부터 자유롭게 만듬(IoC)
- 전통적인 싱글톤 패턴의 단점을 알아보고, 싱글톤 패턴의 단점을 극복할 수 있도록 설계된
컨테이너 활용 방법을 알아봄(싱글턴 레지스트리)
- 설계 시점과 코드에는 클래스와 인터페이스 사이의 느슨한 의존관계만 만들어놓고, 런타임시에
실제 사용할 구체적인 의존 오브젝트를 제3자(DI 컨테이너)의 도움으로 주입받아서 다이나믹한
의존관계를 갖게 해주는 IoC의 특별 케이스를 알아봄
- 의존 오브젝트 주입 시 생성자/수정자 메서드 방식 알아봄
- XML을 이용한 DI 설정정보를 만드는 방법 알아봄
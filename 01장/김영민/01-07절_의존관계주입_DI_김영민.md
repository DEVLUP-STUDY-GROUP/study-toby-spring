# 1.7 의존관계 주입(DI)

> DaoFactory 일반 팩토리 클래스를 설정 파일(@Configuration, @Bean)을 사용하여 스프링 IoC 컨테이너에 의해  
> 관리가 되어지는 Bean(빈 객체)로 등록하는 방법을 해보았다.  
>
> 그리고 스프링은 기본적으로 싱글톤 레지스트리를 지원하여, 모든 Bean(빈 객체)들은 싱글턴으로 생성된다.  
> 그 이유는 스프링은 엔터프라이즈 기업을 대상을 목표로 하였기에 성능이 잘 나와야 했음.

- 1-5절, 1-6절에서 진행한 내용은 아래와 같다
  - `스프링을 IoC 컨테이너로 적용`하는 방법
  - `싱글톤 레지스트리`로서의 `특징` 확인
- 이번에는 스프링의 IoC에 대해 좀 더 깊이 알아본다

## 1.7.1 제어의 역전(IoC)와 의존관계 주입

- DaoFactory 처럼 `객체`를 `생성`하고 `관계를 맺어주는` 등의 작업을 담당하는 기능을 `스프링 IoC 컨테이너`
- 한 가지 짚고 넘어갈 것은 IoC라는 용어는 매우 느슨하게 정의되어서 폭 넓게 사용되는 용어
  - 때문에 스프링을 IoC 컨테이너라고만 해서는 `스프링이 제공하는 기능의 특징을 명확히 설명 못한다`
  - ex) 스프링이 서버에서 동작하는 컨테이너라는 뜻인지?
  - ex) IoC 개념이 적용된 템플릿 메서드 패턴을 이용해 만든 프레임워크라는 뜻인지?
- 스프링 IoC 기능의 대표적인 동작원리는 `의존관계 주입`(`DI`)이라고 불린다
- 그래서 초기에는 주로 IoC 컨테이너라 불리던 스프링이 지금은 `의존관계 주입 컨테이너` 또는 `DI 컨테이너` 라고 불린다
  - 결국은 DI(Dependency Injection)을 수행해주는 주체는 컨테이너(IoC, DI Container)이기 때문이라 생각함

### 🔥의존관계 주입, 의존성 주입, 의존 오브젝트 주입?

DI(Dependency Injection)은 여러가지 우리말로 번역돼서 사용된다.  
그 중 가장 흔히 사용되는 용어가 `의존성 주입`이다.

> 🙁 의존성 주입? -> 의존성을 주입한다?

하지만 `의존성`이라는 말은 DI의 의미가 무엇인지 잘 드러내주지 못한다.  
또한 `의존`(`종속`) `오브젝트 주입`이라고도 부르기도 하는데, 이때는 <u>`DI가 일어나는 방법`</u>에  
초점을 맞춘 것이다.

> ✏️ 엄밀히 말해서 Object(오브젝트)는 다른 Object(오브젝트)에 주입할 수 있는 것이 아니다.  
> 즉, Object(오브젝트)를 주입하는 것이 아니라 Object(오브젝트)의 reference(래퍼런스)가 전달된 뿐이다.

🌠 DI의 `핵심`은 <u>`오브젝트 래퍼런스`를 `외부로부터 주입`받고 이를 통해 `여타 오브젝트와 다이내믹하게 의존관계`가 만들어지는 것이 핵심이다.</u>

## 1.7.2 런타임 의존관계 설정

### 의존관계?

> 먼저 의존 관계가 무엇인지 생각해보자?  
> 의존 하는 관계라고 할까나?... A 클래스와 B 클래스가 서로 의존하고 있다?

![클래스의_의존관계_다이어그램](/01장/김영민/img/08.png)

> ✏️ 의존관계란 '한 객체'가 '다른 객체'의 '기능'이나 '서비스'에 '의존'하는 '관계'를 의미한다

- 두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 `방향성을 부여`해야 한다
- 즉, 누가 누구한테 의존하고 있는지를 명시해야 함
- UML에서는 위와 같이 의존관계를 점섬으로 된 화살표로 표현한다
- A 클래스는 B 클래스에 의존한다 할 수 있다

> ✏️ 그렇다면 의존 한다는 것은 어떤 의미일까?

- 의존한다는건 `의존대상이 변하면 의존 대상을 바라보는 주체도 변한다는 뜻`을 의미한다
- 여기서는 B가 변하면 그것이 A에 영향을 미친다는 뜻
- <u>대표적인 예로 A가 B에 정의된 메서드를 호출해서 사용하는 경우를 들 수 있음</u>
- 의존관계에는 방향성이 있으며 B는 A에 의존하고 있다고 볼 수 없다

### UserDao의 의존관계?

> 🥹 지금까지 작업해온 UserDao에 대해 다시 한번 보자.

![인터페이스를통한_느슨한_결합을_갖는_의존관계](/01장/김영민/img/09.png)

- UserDao가 ConnectionMaker에 의존하고 있는 형태의 그림
- 그림 1-11은 UserDao가 ConnectionMaker 인터페이스를 사용하는 것을 나타낸다

> ✏️ 구체적인 것에 의존하면 안되고 추상적인 것에 의존해야 한다 ( DIP : 의존 역전 법칙 )

현재 UserDao는 ConnectionMaker 인터페이스에만 의존하고 있다. 만약 ConnectionMaker가 변경된다고 하면  
UserDao는 영향을 받겠지만 ConnectionMaker를 구현한 클래스(DConnectionMaker, NConnectionMaker)가 변한다고  
UserDao가 영향을 받지는 않는다. 이렇게 인터페이스에 대해서만 의존관계를 만들면 변화에 영향을 덜 받게된다.

> 🙁 그런데 모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계 말고,  
> '런타임 시'에 오브젝트 사이에서 일어나는 '의존관계'도 있다.

- 🤔 Q/A 런타임 의존관계
  - 설계 시점의 의존관계가 실체화 된 것?
  - 모델링 시점의 의존관계와는 성격이 다름?

```java
// 단순 예시일 뿐입니다
public class UserDao {

    public static void main(String[] args) {
        ConnectionMaker connectionMaker = new NConnectionMaker();
        connectionMaker.connection();
    }
}
```

```java
// 단순 예시일 뿐입니다
public interface ConnectionMaker {

    void connection();

}
```

인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우, UserDao의 오브젝트가 런타임  
시에 사용할 오브젝트가 어떤 클래스로 만든 것인지 미리 알 수 가 없음.  

개발자, 운영자가 사전에 어떤 클래스 오브젝트를 사용할지 정할 수 있지만, 이러한 부분이  
UserDao나 ConnectionMaker 등의 설계와 코드 속에 드러나지 않는다는 말이다.

프로그램 시작되고 UserDao 오브젝트 생성된 후 `런타임 시 의존관계를 맺는 대상`,  
즉 `실제 사용하는 대상`인 `오브젝트`를 `의존 오브젝트`라 말한다.

🌠 `의존관계 주입`은 이렇게 `구체적인 의존 오브젝트`와 그것을 사용할 `주체`, 보통 클라이언트라  
부르는 오브젝트를 `런타임 시에 연결해주는 작업`을 의미한다.

### 의존 관계 주입 충족을 위한 세 가지 조건 (중요)

> 의존 관계의 '핵심'은 설계 시점에는 알지 못했던 두 오브젝트의 관계를  
> 맺도록 도와주는 제 3자(DI 컨테이너)가 존재한다는 것이다.

1. 클래스 모델(UML)이나 코드에는 런타임 시점의 의존관계가 들어나지 않고, `인터페이스에만 의존`하고 있어야함
2. 런타임 시점의 의존 관계는 IoC 컨테이너(3자)가 담당
3. 의존관계는 사용할 오브젝트(Bean)에 대한 래퍼런스를 외부에서 주입 해줌으로써 형성됨

### UserDao의 의존관계 주입

```java
public UserDao() {
    connectionMaker = new DConnectionMaker();
}
```

> UserDao에 적용된 의존관계 주입 기술을 살펴보자

- UserDao와 ConnectionMaker 구현 클래스 간에 의존관계를 느슨하게 만들었음
- 문제는 UserDao가 사용할 구체적인 클래스를 알고 있어야 한다는 점
- 위 코드는 설계 시점에서 이미 구체적인 클래스의 존재를 알고 있음
  - UserDao가 아래 2가지를 관리하고 있는 셈
    - 모델링 시의 의존 관계
    - 런타임 시의 의존 관계
- IoC 방식을 써서 UserDao로부터 런타임 의존관계를 드러내는 코드는 제거
- 제 3의 존재에 런타임 의존관계 결정 권한을 위임
  - 최종적으로 DaoFactory

```java
public class UserDao {

    private ConnectionMaker connectionMaker;

    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }
}
```

```java
public class DaoFactory {

    // userDao 객체를 생성하는 방법 + 오브젝트 반환
    public UserDao userDao() {
        // 오브젝트의 생성 방법을 결정, 해당 오브젝트를 반환 -> 팩토리
        ConnectionMaker connectionMaker = new DConnectionMaker();
        UserDao userDao = new UserDao(connectionMaker);
        return userDao;
    }
}
```

- 의존관계 주입을 위한 코드

![런타임_의존관계주입_사용_의존관계](/01장/김영민/img/10.png)

- DI(Dependency Injection)이란 `자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고` 수동적으로 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어맞는다.

## 1.7.3 의존관계 검색과 주입

## 1.7.4 의존관계 주입의 응용

### 기능 구현의 교환

### 부가 기능 추가

## 1.7.5 메소드를 이용한 의존관계 주입

## 113 - 130
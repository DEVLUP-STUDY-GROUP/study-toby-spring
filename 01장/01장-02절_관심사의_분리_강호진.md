# 1장 오브젝트와 의존관계

## 1.2 관심사의 분리
- 객체지향의 세계에서는 모든 것이 변함, 오브젝트에 대한 설계와 이를 구현한 코드가 변함
- 객체지향 설계와 프로그래밍이 절차적 프로그래밍 패러다임에 비해 초기에 많은 번거러운 작업을 요구하는 이유
    - 객체지향 기술 자체가 지니는, 변화에 효과적으로 대처할 수 있다는 기술적인 특징 때문
    - 객체지향 기술이 만들어내는 가상의 추상 세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있음
- 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 하려면 분리와 확장을 고려한 설계가 필요
- **모든 변경과 발전은 한번에 한 가지 관심 사항에 집중해서 발생**
    - **변화는 대체로 집중된 한 가지 관심에 대해 일어나지만, 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많음**
    - 관심이 같은 것끼리 모으고, 관심이 다른 것은 따로 떨어져 있게 함
- **관심사의 분리 (Separation of Concerns)**
    - 프로그래밍 기초 개념 중 하나
    - 관심이 같은 것끼리 하나의 객체 안에 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 따로 떨어져서 서로 영향을 주지 않도록 분리
    - 관심사가 같은 것끼리 모으고, 다른 것은 분리해줌으로써 같은 관심에 효과적으로 집중할 수 있게 만들어 줌
- UserDao 관심사 분리
    - DB연결과 관련된 관심
    - DB에 보낼 SQL 문장을 담을 statement를 만들고 실행하는 관심
    - 사용한 리소스를 시스템에 반납하는 관심
- 수많은 동시 사용자가 있고, 한번 시작하면 장기간 운용되는 서버에서는 예외 상황에 적절하게 대응하여 공유 리소스를 반환하지 않는 일이 없도록 주의
- 중복 코드의 메소드 추출은 관심의 종류에 따라 코드를 구분해 놓았기 때문에 한 가지 관심에 대한 변경이 일어날 경우, 관심이 집중되는 부분의 코드만 수정 가능
- 관심이 다른 코드에 있는 메소드에는 영향을 주지 않고, 관심 내용이 독립적으로 존재하므로 수정이 간단
- 코드를 수정한 후에는 기능에 문제가 없다는 보장을 위해 검증이 필요, 단위 테스트 진행
- 리펙토링 (Refactoring)
    - 여러 메소드에 중복되어 등장하는 특정 관심 사항이 담긴 코드를 별도의 메소드로 분리, 기능에는 영향을 주지 않으면서 코드의 구조만 변경
    - 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술
    - 리팩토링을 하면 코드 내부의 설계가 개선되어 코드를 이해하기 더 편해지고 변화에 효율적으로 대응
    - 생산성은 올라가고 코드의 품질은 높아지며, 유지 보수하기 용이해지고, 견고하면서도 유연한 제품 개발 가능
    - 객체지향 개발자가 반드시 익혀야 하는 기법
- **메소드 추출 (extract method)**: 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아냄
- 상속을 통한 확장
    - 추상 메소드는 메소드 코드는 없지만 메소드 자체는 존재
    - 클래스의 계층 구조를 통해 두 개의 관심이 독립적으로 분리, 변경 작업이 용이해짐
- 상속을 통한 상하위 클래스의 관계는 생각보다 밀접함, 이미 상속 구조를 만들어버리면 다른 목적으로 상속을 적용하기 힘듦
- 서브 클래스는 슈퍼 클래스의 기능을 직접 사용 가능, 슈퍼 클래스 내부의 변경이 있을 때, 모든 서브 클래스를 함께 수정하거나 재개발이 필요
- **디자인 패턴**
    - 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션
    - 주로 객체지향 설계에 관한 것이고, 대부분 객체 지향적 설계 원칙을 이용해 문제를 해결
    - 패턴의 설계 구조가 대부분 비슷한 이유 → 객체지향 설계로부터 문제를 해결하기위 적용할 수 있는 확장성 추구 방법이 대부분 클래스 상곡, 오브젝트 합성으로 패턴의 결과로 나온 코드나 설계구조가 거의 비슷
    - 패턴에서 가장 중요한 것은 각 패턴의 핵심이 담긴 목적과 의도
        - 패턴이 적용할 상황, 해결해야 할 문제, 솔루션의 구조와 각 요소의 역할과 함께 각 패턴의 핵심이 담긴 목적 또는 핵심 의도 파악 필요
- **템플릿 메소드 패턴 (template method pattern)**
    - 슈퍼 클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤, 서브 클래스에서 메소드를 필요에 맞게 구현하여 사용하도록 하는 방법
    - 알고리즘의 구조를 정의하고, 일부 단계를 서브 클래스에게 연기 → 서브 클래스에서 알고리즘의 구조 변경 없이 특정 단계를 재정의
    - 상속을 통해 슈퍼 클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법
    - 스프링에서 자주 사용되는 디자인, 행동 패턴
    - 알고리즘의 특정 단계의 구현을 서브 클래스에게 위임
    - **템플릿 메소드 (template method)**: 슈퍼 클래스에서 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의해두고 이를 활용해 코드의 기본 알고리즘을 담고 있은 메소드
    - **훅 메소드 (hook method)**: 슈퍼 클래스에서 디폴트 기능을 정의해두거나 비워두었다가 서브 클래스에서 선택적으로 오버라이딩 할 수 있도록 만든 메소드
- **팩토리 메소드 패턴 (factory method pattern)**
    - 서브 클래스에서 구체적인 오브젝트의 생성 방법을 결정하게 하는 것 → 객체 생성을 서브 클래스에게 위임하는 생성 패턴
    - 객체 생성 로직을 서브 클래스에게 위임, 객체의 구체적인 타입을 서브 클래스에서 결정
    - 상속을 통해 기능을 확장하게 하는 패턴
    - 슈퍼 클래스 코드에서는 서브 클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용
    - 슈퍼 클래스에는 객체 생성에 대한 인터페이스만 정의되어 있고, 실제 생성은 서브 클래스에서 결정
    - **팩토리 메소드 (factory method)**: 서브 클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드

# 1장 오브젝트와 의존관계

> 스프링은 자바를 기반으로 한 기술이다. 스프링이 자바에서 가장 중요하게 가치를 두는 것은 바로  
> 객체지향 프로그래밍이 가능한 언어라는 점이다. 1장에서는 스프링이 어떤 것이고, 무엇을 제공하는지보다는  
> 스프링이 관심을 갖는 대상인 오브젝트의 "설계"와 "구현", "동작 원리"에 더 집중하길 바란다.

## 1.1 초난감 DAO

> **DAO**  
> DAO(Data Access Object)는 **DB를 사용**해 **데이터**를 **조회**하거나 **조작**하는 기능을 전담하는 **오브젝트**를 말한다

- 사용자 정보를 JDBC API를 통해 DB에 저장하고 조회할 수 있는 간단 DAO 하나를 만들어본다

### 1.1.1 User

> **자바빈**  
> 자바빈은 다음 두 가지 관례를 따라 만들어진 오브젝트를 지칭함  
> - 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 가지고 있어야 함, 툴이나 F/W에서 **리플랙션**을 통해 Object를 생성하기 때문이다  
> - 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 의미하며, set 혹은 get으로 시작하는 메서드를 이용해 수정 또는 조회 가능

- 사용자 정보를 저장할 때는 자바빈 규약을 따르는 오브젝트를 이용하면 편리하다
- User 객체를 만들고 id, name, password 세 개의 인스턴스 변수를 갖는 클래스를 생성한다

```java
public class User {
    String id; // seq
    String name; // 이름
    String password; // 비밀번호

    public String getId() { 
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
}
```

- 이제 User 오브젝트가 담긴 정보가 실제 보관될 DB 테이블 하나를 만든다
- 테이블 이름은 USER로 프로퍼티는 User 클래스의 프로퍼티와 동일

| 필드명 | 타입 | 설정 |
|------|------|------|
| UserId | VARCHAR(10) | Primary Key |
| Name | VARCHAR(20) | Not Null |
| Password | VARCHAR(20) | Not Null |

- MySQL 사용 시 다음과 같은 CREATE 구문 입력

```sql
create table users(
    id varchar(10) primary key,
    name varchar(20) not not null,
    password varchar(10) not null
)
```

### 1.1.2 UserDao

- 사용자 정보를 DB에 넣고 관리하기 위해 DAO 클래스 생성한다 ( UserDAO )
- 기본적인 CRUD 기능이 필요하지만, 일단 새로운 사용자를 생성하고(add), 사용자 정보를 읽어오는(get) 기능 먼저 만든다
- JDBC를 이용하는 작업 순서는 아래와 같다
  - DB 연결을 위한 Connection을 가져옴
  - SQL에 담을 Statement(or PreparedStagement)를 만든다
  - 만들어진 Statement 실행
  - 조회의 경우 SQL 쿼리 실행 결과를 ResultSet으로 받아 Obj에 옮겨준다
  - 작업 중 생성된 리소스는 반드시 닫는다
  - JDBC API가 만드는 예외는 잡아서 직접 처리, throws를 선언하여 처리한다 

```java
public class UserDao {

    // 유저를 추가하는 함수
    public void add(User user) throws ClassNotFoundException, SQLException { 
        Class.forName("com.mysql.jdbc.Driver")；
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book")；

        PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)")；
        ps.setString(1, user.getld());
        ps.setString(2, user.getName())；
        ps.setString(3, user.getPassword())；

        ps.executeUpdate()；

        ps.close()；
        c.close()；
    }

    // ID 기반 유저를 조회하는 함수
    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver")；
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book")；
        
        PreparedStatement ps = c.prepareStatement("select * from users where id = ?")；
        ps.setString(1, id)；

        Result Set rs = ps.executeQuery()； 
        rs.next()；
        User user = new  User()；
        user.setld(rs.getString("id"))；
        user.setName(rs.getString("name"))；
        user.setPassword(rs.getString("password"))；
        
        rs.close()；
        ps.close()；
        c.close()；
        return user；
    }
}
```

- 위에서는 간단하게 add, get 하는 함수 생성 해보았다
- 테스트를 위해서 다음에는 DAO 테스트 코드를 작성 해보자

### 1.1.3 main()을 이용한 DAO 테스트 코드

- 만들어진 코드의 기능을 검증하고자 할 때는 `오브젝트 스스로 자신을 검증하게 만들면 된다`
- 모든 클래스에는 자신을 엔트리 포인트로 설정해 직접 실행이 가능하게 해주는 `static main`이 존재한다

```java
public static void main(String[] args) throws ClassNotFoundException, SQLException {
    UserDao dao = new UserDao();
    
    User user = new User();
    user.setId("whiteship");
    user.setName("백기선");
    user.setPassword("married");

    dao.add(user); // userDao에 User 객체를 넣고 add(INSERT) 를 통해 DB에 데이터 저장
    System.out.println(user.getId() + "등록 성공");

    User user2 = dao.get(user.getId); // 회원 조회
    System.out.println(user2);
    System.out.printin(user2.getPassword())； 

    System.out.println(user2.getld() + "조회 성공");
}
```

- 위 클래스를 실행하면 다음과 같은 결과를 얻을 수 있음

```java
whiteship 등록 성공 
백기선
married
whiteship 조회 성공
```

- ❓ `하지만 지금 만든 UserDao 클래스 코드에는 여러가지 문제가 존재한다`
- ✅ `다음에는 DAO의 분리를 통해 스프링 F/W에 맞게 소스를 수정 해보자`

## 1.2 DAO의 분리

### 1.2.1 관심사의 분리

- 세상에는 변하는 것과 변하지 않는 것이 있다. 하지만 객체지향 세계의 모든것은 변한다
- 여기서 변한다는 것은 변수, Obj 필드값이 변하는것이 아니다
  - `오브젝트에 대한 설계와, 이를 구현한 코드가 변한다는 뜻`
- `개발자가 객체를 설계할 때 가장 염두해야 하는 부분은 미래의 변화를 어떻게 대비할 것인가 이다`

> 분리에 대한 한 가지 예를 들어보자, 기능 요구 사항을 주는 경우에 "DB를 Oracle에서 MySQL로 바꾸면서, 웹 화면의  
> 레이아웃을 다중 프레임 구조에서 단일 프레임에 Ajax를 적용한 구조로 바꾸고, 매출이 일어날 때 지난달  
> 평균 매출액보다 많으면 감사 시스템의 정보가 웹 서비스로 전송되는 동시에 로그는 날짜 포맷을 6자리에서  
> Y2K를 고려해 8자리로 바꿔라"는 식으로 발생하지 않는다.  
>
> 무슨 애긴가 하면, 모든 변경과 발전은 한 번에 한 가지 관심사하에 집중하여 일어난다는 뜻이다.  
> 문제는, 변화는 대체로 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한곳에 집중되지 않는 경우가   
> 많다는 점이다.  
>
> ex) DB 접속 암호 변경을 위해 DAO 클래스 수백개를 수정해야 하는경우?  
> ex) 트랜잭션 기술을 변경 하였다고 비즈 로직이 담긴 코드의 구조를 모두 변경해야 하는 경우?  
>  
> 😶 여기서 말하는 관심사의 분리라는 건 관심사가 같은 것은 같은 것끼리 모으고 다른 것은  
> 분리 해줌으로써 같은 관심에 효과적으로 집중할 수 있게 만드는 것

### 1.2.2 커넥션 만들기의 추출

```java
// 유저를 추가하는 함수
public void add(User user) throws ClassNotFoundException, SQLException { 
    Class.forName("com.mysql.jdbc.Driver")；
    Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book")；

    PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)")；
    ps.setString(1, user.getld());
    ps.setString(2, user.getName())；
    ps.setString(3, user.getPassword())；

    ps.executeUpdate()；

    ps.close()；
    c.close()；
}

// 🤣 아래와 같은 메서드가 1000개라면?? DB 변경 작업 있을 경우 모든 함수 수정해주어야 함
// public void update() {
//     Class.forName("com.mysql.jdbc.Driver");
//     Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
//     ...
// }

// public void delete() {
//     Class.forName("com.mysql.jdbc.Driver");
//     Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
//     ...
// }

// public void changeMemberFlag() {
//     Class.forName("com.mysql.jdbc.Driver");
//     Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
//     ...
// }
```

- UserDao의 add 메서드를 보면 메서드 하나에만 적어도 `세 가지 관심사항`이 존재
  - 01) DB 연결에 대한 관심사
  - 02) SQL 작성에 대한 관심사
  - 03) 리소스 반환에 대한 관심사

### 중복 코드의 메서드 추출

- 관심사 분리를 위해 가장 먼저 할일은 `DB 커넥션을 가져오는 중복 코드를 분리하는 것`
- 중복된 DB 연결 코드 -> getConnection() 메서드로 분리

```java
// TO-BE: refacotor

public void add(User user) throws ClassNotFoundException, SQLException {
    Connection c = getConnection(); // DB 커넥션 관련 객체 획득
    ...
}

public User get(String id) throws ClassNotFoundException, SQLException {
    Connection c = getConnection(); // DB 커넥션 관련 객체 획득
    ...
}

public Connection getConnection() throws ClassNotFoundException, SQLExpception {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springboot", "spring", "book");
}
```

- 이렇게 되면 여러개의 함수 수정 없이 1개의 함수(getConnection())만 수정하면 됨
- `관심사를 분리하고, SRP(Single Responsbility Principle) 원칙에 맞춰 작성`

### 1.2.3 DB 커넥션 만들기의 독립

- UserDao가 발전하여 인기를 끌더니 N사와 D사에서 사용자 관리를 위해 UserDao를 구매
- 문제 01) 납품 과정에서 N사와 D사는 각기 다른 종류의 DB를 사용하고 있음
- 문제 02) 추후에도 DB가 바뀔 수 있다고 함

### 상속을 통한 확장

- 위 문제를 해결하기 위한 방법은 UserDao 코드를 한 단계 더 분리하면 된다
- `UserDao는 추상메서드 제공 N사 D사는 UserDao를 상속하여 기능을 완성 한다`
- 그림 1-1을 참고하자

![1-1_상속을통한_userdao_확장.png](./img/01.png)

- 리팩터링 소스는 아래와 같다

```java
public abstract class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
        ...
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
        ...
    }

    // DB Connection 부분을 추상 메서드로 작성
    public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}
```

```java
public class NUserDao extends UserDao {

    public Connection getConnection() throws ClassNotFoundException, SQLException {
        // N사 DB Connection 생성 코드
    }
}

public class DUserDao extends UserDao {
    public Connection getConnection() throws ClassNotFoundException, SQLException {
        // D사 DB Connection 생성 코드
    }
}
```

- 추상 클래스는 객체 생성이 불가능하고 하위 클래스는 이러한 추상 클래스를 상속하여 기능을 이용(add, get 함수)하고 확장(getConnection 함수)하는 목적을 가지고 있다. 이에 반해서 인터페이스는 기능의 확장보다는 하위 클래스가 상위 구현 클래스와 동일한 행위를 수행하도록 보장을 하기 위해 사용이 됨
- 위와 같이 `슈퍼클래스(UserDao)에는 기본적인 로직의 흐름`(`커넥션 가져오기, SQL 생성, 실행, 반환`)`을 만들고`, `그 기능의 일부를 추상 메서드나 오버라이딩이 가능한 protected 메서드 등으로 만든 뒤 서브 클래스에서 이런 메서드를 필요에 맞게 구현`해서 사용하도록 하는 방법을 디자인 패턴에서는 **`템플릿 메서드 패턴`** 이라 한다
- UserDao의 getConnection() 메서드는 `Connection 타입 오브젝트를 생성 및 반환`한다는 기능을 정의해둔 `추상 메서드`이다. 그리고 UserDao의 서브 클래스의 getConnection() 메서드는 `어떤 Connection 클래스 오브젝트를 어떻게 생생`할 것인지 결정하는 방법이라 볼 수 있음, 이렇게 `서브 클래스에서 구체적인 오브젝트 생성 방법을 결정`하게 하는 것을 **`팩토리 메서드 패턴`** 이라고 부른다

// Q. 템플릿 메서드 패턴 vs 팩토리 메서드 패턴의 차이는? 

### 디자인 패턴

- 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용하는 재사용 가능한 솔루션

### 템플릿 메서드 패턴

```java
public abstract class Super {
    public void templateMethod() {
        // 기본 알고리즘 코드
        hookMethod();
        abstractMethod();
        ...
    }

    protected void hookMethod() {  } // 선택적 오버라이드 가능 훅 메서드
    public abstract void abstractMethod(); // 서브 클래스에서 반드시 구현해야 하는 추상메서드
}

public class Sub1 extends Super {
    protected void hookMethod() {
        ...
    }

    public void abstractMethod() {
        ...
    }
}
```

- `상속`을 통해 `슈퍼클래스`의 `기능 확장` 시 주로 사용
- `변하지 않을 기능`은 `슈퍼클래스`에 `자주 변경되며 확장 필요 기능`은 `서브 클래스`에 작성
- 슈퍼클래스에서 `디폴트 기능`을 정의해두거나 비워뒀다가 서브클래스에서 선택적 오버라이딩이이 가능하게 만든 메서드를 `훅`(`hook`) 메서드라 한다
- 서브클래스에서는 추상 메서드를 구현하거나, 훅 메서드를 오버라이딩하여 기능 확장을 수행


### 팩토리 메서드 패턴

> 😒 팩토리 메서드와 팩토리 메서드 패턴은 엄연히 다른 개념  
> 팩토리 패턴은 객체 생성과 관련된 디자인 패턴이다

- 템플릿 메서드 패턴과 동일하게 `상속을 통해 기능을 확장`할때 사용하는 방법

// Q. 추가 정리 필요?

## 1.3 DAO의 확장

### 1.3.1 클래스의 분리

- 이번에는 관심사가 다르고 변화의 성격이 다른 이 두 가지 코드를 분리 할 것 이다
- 두 개의 관심사를 독립시키고 손쉽게 확장 할 수 있는 방법에 대해 알아본다
- 지금까지 수행한 작업은 다음과 같다
  - 1) 독립된 메서드(getConnection())을 만들어서 분리
  - 2) 상(UserDao)/하위 클래스(NUserDao, DUserDao)로 분리
  - 3) 이번에는 상속관계 아닌 완전 독립적 클래스로 만들어보자
  - 4) `DB 관련 로직 서브 클래스가 아닌 별도의 클래스에 담아둔다`
  - 4-1) `이렇게 만든 클래스를 UserDao가 이용하면 끝` 

![1-3 두 개의 독립된 클래스로 분리한 결과](./img/02.png)

- 그림 1-3 처럼 SimpleConnectionMaker 클래스 생성 후 DB 생성 기능을 추가한다
- SimpleConnectionMaker의 오브젝틑 생성 후 add/get 메서드 이용 DB 커넥션을 가져온다

```java
public class UserDao {
    private SimpleConnectionMaker simpleConnectionMaker;

    public UserDao() {
        simpleConnectionMaker = new SimpleConnectionMaker();
    }
    
    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = simpleConnectionMaker.makeNewConnection();
        ...
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = simpleConnectionMaker.makeNewConnection();
        ...
    }

    // public Connection getConnection() throws ClassNotFoundException, SQLExpception {
    //     Class.forName("com.mysql.jdbc.Driver");
    //     Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springboot", "spring", "book");
    // }
}
```

```java
public class SimpleConnectionMaker {
    public Connection getConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springboot", "spring", "book");
        return c;
    }
}
```

- **문제 01**) N 사와 D 사에 UserDao 클래스만 공급하고 상속을 통해 DB 커넥션 기능 확장이 이제 불가능
  - UserDao의 코드가 SimpleConnectionMaker 클래스에 종속되어 있기 때문에 상속을 사용했을때처럼
  UserDao 코드 수정 없이 DB 커넥션 생성 기능 변경 방법이 없음
  - // Q. 이 말인 즉슨, 오버라이딩을 통해 소스 재정의가 불가능하다는 의미?
- **문제 02**) 다른 방식으로 DB 커넥션 제공 클래스 사용을 위해서는 UserDao의 다음 소스 수정 필요

```java
simpleConnectionMaker = new SimpleConnectionMaker(); // 생성자 호출 시점에 해당 객체를 주입 받아서 인스턴스 변수에 넣어둔다
```


### 1.3.2 인터페이스의 도입

> 인터페이스는 자신을 구현한 구현 클래스의 정보를 모두 감춰버린다

- 클래스를 분리하면서도 위 같은 문제를 해결하려면?
  - 두 개의 클래스가 서로 긴밀하게 연결되지 않도록 중간에 추상적인 느슨한 연결고리 생성
  - 추상화란 핵심적인 개념을 추려내는 것
  - 자바에서 추상화를 위해 가장 유용한 도구는 인터페이스
- 인터페이스는 어떤 일을 하겠다는 기능만 정의하고, 구현 방법은 나타나 있지 않다

![인터페이스_도입_결과](./img/03.png)

```java
public interface ConnectionMaker {

    public Connection makeConnection() throws ClassNotFoundException, SQLException;

}
```

- 고객에게 납품시 UserDao와 ConnectionMaker 인터페이스도 전달
- D사의 개발자라면 다음과 같이 인터페이스를 구현한 클래스를 만들것이다

```java
public class DConnectionMaker implements ConnectionMaker {
    ...
    public Connection makeConnection() throws ClassNotFoundException, SQLException {
        // D사의 독자적인 방법 사용
    }
}
```

- 다음으로는 UserDao 소스 수정

```java
public class UserDao {
    private ConnectionMaker connectionMaker; // 인터페이스를 통해 접근하기에 구체적인 클래스 정보 몰라도 됨

    public UserDao() {
         // 앗! 그런데 여기 클래스 이름 나오네? <-> 지금은 D사 전용인데?
         // 만약 N사 전용으로 만드려고 한다면? new NConnectionMaker()를 받아서 사용해야 할 것이다
        connectionMaker = new DConnectionMaker();
    }
    
    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();
        ...
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.connectionMaker();
        ...
    }
}
```

- UserDao의 add(), get() 메소드와 필드에는 ConnectionMaker라는 인터페이스와 인터페이스의 메서드인 makeConnection만 사용하도록 했다. 그러니 이제는 아무리 N사와 D사가 DB 접속용 클래스를 다시 만든다고 해도 뜯어 고칠 일은 없어 보인다.
- 하지만 코드를 살펴보면 아직 고치 부분이 보인다

```java
public UserDao {
    ...
    UserDao() {
        connectionMaker = new DConnectionMaker();
    }
}
```

### 1.3.3 관계설정 책임의 분리

```java
public UserDao(ConncetionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
}
```

```java
public class UserDaoTest {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        // N사 ConnectionMaker connectionMaker = new NConnectionMaker();
        ConnectionMaker connectionMaker = new DConnectionMaker();
        UserDao dao = new UserDao(connectionMaker);
    }
}
```

### 1.3.4 원칙과 패턴

- 현재까지 초난감 DAO를 수정했는데 키워드를 정리 해보자

### 개방 폐쇄 원칙(OCP: Open Closed Principle)

- 개방 폐쇄 원칙을 이용하면 지금까지 해온 리팩토링 작업의 특징 및 개선 효과를 설명할 수 있다
- `클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다`
- 현재 UserDao는 DB 연결 방법 기능을 확장하는데 열려있으며 영향을 받지 않고 기능 확장 가능

### 높은 응집도와 낮은 결합도

- 개방 폐쇄 원칙은 높은 응집도와 낮은 결합도라는 소프트웨어 개발의 고전적인 원리로도 설명이 가능함
- `응집도가 높다`는건 `하나의 클래스`가 `하나의 책임` 또는 `관심사`에 집중되어 있다는 뜻

### 낮은 결합도

- 낮은 결합도는 높은 응집도보다 더 민감한 원칙
- `결합도란 하나의 오브젝트 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에서 변화를 요구하는 정도`
- ConnectionMaker 인터페이스 도입으로 구현 클래스가 변경 되어도 DAO 코드 변경 불필요

### 전략 패턴

![전략패턴](./img/04.png)

- 전략 패턴을 구성하는 세 요소
  - 전략 메서드를 가진 전략 객체
  - 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자/소비자)
  - 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트
- 개선한 UserDaoTest-UserDao-ConnectionMAker 구조를 디자인 패턴의 시각으로 보면 전략 패턴에 해당한다고 볼 수 있음
- 전략 패턴은 자신의 기능 맥락(Context)에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 알고리즘 클래스에 따라서 사용할 수 있게 만든 패턴이다
- UserDao는 전략 패턴의 `컨텍스트`에 해당
- UserDaoTest는 `클라이언트`에 해당
- NDConnectionMaker은 `전략` 객체에 해당

## 1.4 제어의 역전(IoC)

### 1.4.1 오브젝트 팩토리

### 1.4.2 오브젝트 팩토리의 활용

### 1.4.3 제어권의 이전을 통한 제어관계 역전

## 1.5 스프링의 IoC

### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC

### 1.5.2 애플리케이션 컨텍스트의 동작 방식

### 1.5.3 스프링 IoC의 용어 정리

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

### 1.6.2 싱글톤과 오브젝트의 상태

### 1.6.3 스프링 빈의 스코프

## 1.7 의존관계 주입(DI)

### 1.7.1 제어의 역전(IoC)와 의존관계 주입

### 1.7.2 런타임 의존관계 설정

### 1.7.3 의존관계 검색과 주입

### 1.7.4 의존관계 주입의 응용

### 1.7.5 메소드를 이용한 의존관계 주입

## 1.8 XML을 이용한 설정

### 1.8.1 XML 설정

### 1.8.2 XML을 이용하는 애플리케이션 컨텍스트

### 1.8.3 DataSource 인터페이스로 변환

### 1.8.4 프로퍼티 값의 주입

## 1.9 정리
# 1장 오브젝트와 의존관계

## 1.3 DAO의 확장
- 관심사에 따라 분리한 오브젝트들은 제각기 독특한 변화의 특징이 있음, 변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻
- 추상 클래스를 만들고 이를 상속한 서브 클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만든 이유
    - 변화의 성격이 다른 것을 분리해서, 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해
- 기능에 변화가 없다는 것은 이런 리팩토링 작업의 전제이기도 하지만, 검증 내용이기도 함
- 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록, 중간에 추상적인 느슨한 연결 고리를 만들어주는 것
- **추상화 (abstract)**
    - 어떤 것들의 공통적인 성격을 뽑아내어 따로 분리해내는 작업
    - 자바에서 추상화를 위해 제공하는 가장 유용한 도구는 인터페이스
- **인터페이스 (interface)**
    - 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춤
    - 오브젝트를 만들려면, 구체적인 클래스 하나를 선택해야 하지만 인터페이스로 추상화를 진행한 경우
        - 최소한의 통로를 통해 접근하는 쪽에서 오브젝트를 만들 때, 사용할 클래스가 무엇인지 몰라도 가능
    - 인터페이스를 통해 접근하게 하면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없음
    - 어떤 일을 하겠다는 기능만 정의, 어떻게 하겠다는 구현 방법은 나타나 있지 않음, 인터페이스를 구현한 클래스들이 알아서 결정함
- 직접 생성자를 호출해서 직접 오브젝트를 만드는 방법도 있지만, 외부에서 만들어 준 것을 가져오는 방법도 존재
    - 오브젝트는 얼마든지 메소드 파라미터 등을 이용해 전달할 수 있으므로, 외부에서 만든 걸 가져올 수 있음
    - 외부에서 만든 오브젝트를 전달 받으려면, 메소드 파라미터나 생성자 파라미터를 이용 가능
    - 해당 인터페이스 타입의 오브젝트라면 파라미터로 전달 가능, 파라미터로 제공 받은 오브젝트는 인터페이스에 정의된 메소드만 이용 시
        - 오브젝트가 어떤 클래스로부터 만들어졌는지 신경 쓰지 않아도 됨
- 클래스 사이의 관계는 코드에 다른 클래스 이름이 나타나기 때문에 만들어짐
- **다형성 (polymorphism)**
    - 코드에서는 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용 가능
    - 여러 형태를 가질 수 있다는 뜻, 객체 지향 프로그래밍의 주요 원칙 중 하나
    - 다형성을 통해 여러 객체가 동일한 인터페이스를 공유하면서도 각자의 고유한 방식으로 해당 인터페이스를 구현 가능
- 인터페이스를 도입하고 클라이언트의 도움을 얻는 방법 → 상속을 사용해 비슷한 시도를 했을 경우에 비해 훨씬 유연함
- **객체지향 설계 원칙 (SOLID)**
    - 객체지향의 특징을 잘 살릴 수 있는 설계의 특징
    - 원칙이라는 건 어떤 상황이든 100% 지켜져야 하는 절대적인 기준이라기보다는 예외는 있겠지만 대부분 상황에 잘 들어맞는 가이드라인과 같음
    - 디자인 패턴은 특별한 상황에서 발생하는 문제에 대한 좀 더 구체적인 솔루션이라면, 객체지향 설계원칙은 더 일반적인 상황에서 적용 가능한 설계 기준
    - 객체지향 디자인 패턴은 대부분 객체지향 설계 원칙을 잘 지켜서 만들어짐
    - **단일 책임 원칙 (SRP, Single Responsibility Priciple)**
        - **예정…**
    - **개방 폐쇄 원칙 (OCP, Open-Closed Principle)**
        - 클래스나 모듈은 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 함
        - 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중의 하나
        - 인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 개방되어 있음
            → 반면 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어 있음
        - 잘 설계된 객체지향 클래스의 구조를 보면 개방 폐쇄 원칙을 잘 지키고 있음
        - 높은 응집도와 낮은 결합도(high coherence and low coupling), 소프트웨어 개발의 고전적인 원리로도 설명 가능
    - **리스코프 치환 원칙 (LSP, Liskov Substitution Priciple)**
        - **예정…**
    - **인터페이스 분리 원칙 (ISP, Interface Segregation Priciple)**
        - **예정…**
    - **의존관계 역전 원칙 (DIP, Dependency Inversion Priciple)**
        - **예정…**
- 높은 응집도와 낮은 결합도
    - 응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중됨
    - 불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않으며, 하나의 공통 관심사는 한 클래스에 모여 있음
    - 높은 응집도는 클래스 레벨 뿐 아니라, 패키지, 컴포넌트, 모듈에 이르기까지 대상의 크기가 달라도 동일한 원리로 적용 가능
    - 응집도가 높다는 것은 변화가 일어날 때, 해당 모듈에서 변하는 부분이 크다는 것으로 설명 가능
    - 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다고 말할 수 있음
    - 모듈의 일부만 변경이 일어나도 된다면, 모듈 전체에서 어떤 부분이 바뀌어야 하는지 파악 필요
        - 그 변경으로 인해 바뀌지 않는 부분에는 다른 영향을 미치지 않는지 확인해야 하는 부담이 생김
    - 작업은 항상 전체적으로 일어나고 무엇을 변경할지 명확하게 다른 클래스의 수정을 요구하지 않을 뿐더러, 기능에 영향을 주지 않는다는 사실을 확인 가능
    - **낮은 결합도는 높은 응집도보다 더 민감한 원칙**, 책임과 관심사가 다른 오브젝트 또는 모듈과 낮은 결합도, 느슨하게 연결된 형태를 유지하는 것이 바람직함
    - 느슨한 연결은 관계를 유지하는데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공, 나머지는 독립적이고 알 필요도 없게 만들어주는 것
    - **결합도가 낮아지면 변화에 대응하는 속도가 높아지고 구성이 깔끔해짐, 확장하기에도 매우 편리**
    - **결합도**: 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도
    - 낮은 결합도란 하나의 변경이 발생할 때, 다른 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태
    - 결합도가 높아지면 변경에 따르는 작업량이 많아지고, 변경으로 인해 버그 발생 가능성이 높아짐
- **전략 패턴 (Strategy Pattern)**
    - (대체 가능한) 전략, 디자인 패턴의 꽃, 개방 폐쇄 원칙의 실현에도 가장 잘 들어 맞는 패턴
    - 자신의 기능, 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리
        - 구현한 구체적인 알고리즘 클래스를 필요에 따라 변경하여 사용 할 수 있음
        - 여기서 알고리즘은 독립적인 책임으로 분리가 가능한 기능을 뜻함
    - 전략 패턴의 적용 방법을 보면 클라이언트의 역할이 잘 설명되어 있음
        - 컨텍스트를 사용하는 클라이언트는 컨텍스트가 사용할 전략을 컨텍스트의 생성자 등을 통해 제공해주는 게 일반적
# 2장 테스트

## 2.4 스프링 테스트 적용

- 빈이 많이지고 복잡해지면 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있음
    - 애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화
    - 단순히 빈 오브젝트를 만드는 정도라면 상관 없음
    - 어떤 빈은 오브젝트가 생성될 때 자체적인 초기화 작업을 진행해서 많은 시간을 필요로 함
- 애플리케이션 컨텍스트가 초기화될 때 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 함
- 테스트를 마칠 때마다 애플리케이션 컨텍스트 내의 빈이 할당한 리소스 등을 깔끔하게 정리하지 않으면 다음 테스트에서 새로은 애플리케이션 컨텍스트가 만들어지면서 문제 발생 가능
- 테스트는 가능한 독립적으로 매번 새로운 오브젝트를 만들어서 사용하는 것이 원칙
    - 애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우, 테스트 전체가 공유하는 오브젝트를 만들기도 함
    - 위 경우에도 테스트는 일관성 있는 실행 결과를 보장, 테스트의 실행 순사가 결과에 영향을 미치지 않아야 함
    - 애플리케이션 컨텍스트는 초기화되고 나면 내부의 상태가 바뀌는 일은 거의 없음
    - 빈은 싱글톤으로 만들었기 때문에 상태를 갖지 않음
    - 애플리케이션 컨텍스트는 한 번만 만들고 여러 테스트가 공유해서 사용해도 됨
- JUnit이 매번 테스트 클래스의 오브젝트를 새로 만듦
    - 여러 테스트가 함께 참조할 애플리케이션 컨텍스트를 오브젝트 레벨에 저장해두면 곤란
    - 테스트가 함께 참조할 애플리케이션 컨텍스트를 저장 가능 
        - 테스트 클래스 전체를 걸쳐 딱 한 번만 실행되는 `@BeforeClass` 스태틱 메소드를 지원
            - `@BeforeClass` 메소드에서 애플리케이션 컨텍스트를 만들어 스태틱 변수에 저장해두고 테스트 메소드에서 사용 가능
        - 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 사용하는 것이 더 편리

### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리

- 스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공
- 테스트 컨텍스트의 지원을 받으면 간단한 애노테이션 설정만으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어 모든 테스트가 공유 가능
- @Runwith는 JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 애노테이션
- `SpringJUnit4ClassRunner`라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정
    - JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들어주고 관리하는 작업을 진행
- `@ContextConfiguration`은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정
- 하나의 애플리케이션 컨텍스트가 만들어져 모든 테스트 메소드에서 사용
    - JUnit은 테스트 메소드를 실행할 때마다 새로운 테스트 오브젝트를 만듦
    - 스프링의 JUnit 확장기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해주는 것
        - 일종의 DI, 애플리케이션 오브젝트 사이의 관계를 관리하기 위한 DI와는 조금 성격이 다름
- 스프링이 애플리케이션 컨텍스트 테스트 개수에 상관없이 한 번만 만들어서 공유하기 때문에 테스트 수행 속도는 매우 빠름
    - 첫 번째 테스트가 실행될 때 최초로 애플리케이션 컨텍스트가 처음 만들어지면서 가장 오랜 시간이 소모
    - 다음부터는 이미 만들어진 애플리케이션 컨텍스트를 재사용할 수 있기 때문에 테스트 실행 시간이 매우 짧아짐
- 스프링 테스트 컨텍스트 프레임워크의 기능은 하나의 테스트 클래스 안에서 애플리케이션 컨텍스트를 공유해주는 것이 전부가 아님
- 여러 개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용 시
    - 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유
    - 수백 개의 테스트 클래스를 만들어도 모두 같은 설정파일을 사용한다고 해도 테스트 전체에 걸쳐 단 한개의 애플리케이션 컨텍스트만 만들어져 사용
    - 덕분에 테스트 성능이 대폭 향샹됨
    - 테스트 클래스마다 다른 설정파일을 사용하도록 만들어도 되고, 몇 개의 테스트에서만 다른 설정 파일을 사용 가능
    - 스프링은 설정파일의 종류만큼 애플리케이션 컨텍스트를 만들고, 같은 설정파일을 지정한 테스트에서는 이를 공유
- `@Autowired`
    - 스프링 DI에 사용되는 특별한 애노테이션
    - `@Autowired`가 붙은 인스턴스 변수가 있으면 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾음
    - 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입
    - 일반적으로는 주입을 위해서는 생성자나 수정자 메소드같은 메소드가 필요하지만 이 경우에는 메소드가 없어도 주입 가능
    - `@Autowired`를 지정하기만 하면 어떤 빈이든 다 가져올 수 있음
    - 타입에 의한 자동 와이어링: 별도의 DI 설정 필요 없이 필드의 타입정보를 이용해 빈을 자동으로 가져올 수 있음
    - 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾음
    - 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없음
    - 타입으로 가져올 빈 하나를 선택할 수 없는 경우에는 변수의 이름과 같은 이름의 빈이 하나 있는지 확인
    - 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외 발생
- 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록
    - 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재, DI도 가능
- 테스트는 필요하다면 얼마든지 애플리케이션 클래스와 밀접한 관계를 맺고 있어도 상관 없음
    - 개발자가 만드는 테스트는 코드 내부 구조와 설정 등을 알고 있고 의도적으로 그 내용을 검증해야 할 필요가 있기 때문
    - 꼭 필요하지 않다면 테스트에서도 가능한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이 좋음

### 2.4.2 DI와 테스트

- DI를 통해 외부에서 사용할 오브젝트를 주입받기 때문에 오브젝트 생성에 대한 부담을 지지 않음
- 코드의 수정 없이도 얼마든지 의존 오브젝트를 바꿔가며 사용 가능
- 인터페이스를 두고 DI를 적용해야 하는 이유
    - 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없음
        - 클래스 대신 인터페이스를 사용하고, new를 이용해 생성하는 대신 DI를 통해 주입받게 하는 건 아주 단순하고 쉬운 작업
        - 언젠가 변경이 필요한 상황이 닥쳤을 때 수정에 들어가는 시간과 비용의 부담을 줄여줌
    - 클래스의 구현 방식은 바뀌지 않는다고 해도 인터페이스를 두고 야를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있기 때문
        - 새로운 기능을 넣기 위해 기존 코드는 전혀 수정할 필요도 없음
        - 추가했던 기능이 필요 없어지면 언제든지 설정파일을 간단히 수정해서 제거 가능
        - 스프링에서 이런 기법을 일반화하여 AOP라는 기술로 만듦
    - 테스트
        - 효율적인 테스트를 손쉽게 만들기 위해서라도 DI 적용 필요
        - 테스트를 잘 활요하려면 자동으로 실행 가능하며 빠르게 동작하도록 테스트 코드를 만들어야 함
            - 가능한 작은 단위의 대상에 국한해서 테스트 필요
        - 테스트 할 대상의 범위가 넓어지면 테스트를 작성하기가 어려워짐
        - DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는 데 중요한 역할을 함
- DI는 애플리케이션 컨텍스트 같은 스프링 컨테이너에서만 할 수 있는 작업이 아님
    - 프레임워크의 도움 없이 직접 DI를 적용 가능
- 스프링 테스트 컨텍스트 프레임워크를 적용 시, 애플리케이션 컨텍스트는 테스트 중에 딱 하나만 만들어지고, 모든 테스트에서 공유하여 사용
    - 애플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하지 않는 것이 원칙
    - 한 번 변경하고 나머지 모든 테스트를 수행하는 동안 변경된 애플리케이션 컨텍스트가 계속 사용 → 바람지갛지 않음
- `@DirtiesContext`
    - 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경하는 것을 알려줌
    - 테스트 컨텍스트는 `@DirtiesContext`이 붙은 테스트 클레스에는 애플리케이션 컨텍스트 공유를 허용하지 않음
    - 테스트 메소드를 수행하고 나면 매번 새로운 애플리케이션 컨텍스트를 만들어서 다음 테스트가 사용하게 해줌
    - 테스트 중에 변경한 컨텍스트가 뒤의 테스트에 영향을 주지 않게 하기 위함
    - 클래스에만 적용할 수 있는 것은 아님 → 메소드의 실행이 끝남
        - 이후에 진행되는 테스트를 위해 변경된 애플리케이션 컨텍스트는 폐기되고 새로운 애플리케이션 컨텍스트가 생성
- 테스트 코드에서 빈 오브젝트에 수동으로 DI 하는 방법은 장점보다 단점이 많음
    - 코드가 많아져 번거롭기도 하고 애플리케이션 컨텍스트도 매번 새로 만들어야 하는 부담이 있음
    - 아예 테스트에서 사용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정파일을 따로 만들어두는 방법을 이용 가능
    - 애플리케이션 컨텍스트도 한 개만 만들어서 모든 테스트에서 공유 가능
    - 설정 파일을 하나 더 작성하고 테스트에 맞게 수정해주는 수고만으로 테스트에 적합한 오브젝트 의존관계를 만들어 사용 가능
- 스프링 DI 컨테이너에 의존하지 않는 경우
    -  스프링 컨테이너를 이용하여 IoC 방식으로 생성되고 DI 되도록 하는 대신 테스트 코드에서 직접 오브젝트를 만들고 DI해서 사용 가능
- 애플리케이션 컨텍스트가 만들어지는 번거로움이 없어져 그만큼 테스트 시간도 절약 가능
    - JUnit은 매번 새로운 테스트 오브젝트를 만들지만 가벼운 오브젝트이므로 별 부담은 없음
    - 가볍고 깔끔한 테스트를 만들 수 있는 이유도 DI를 적용했기 때문
    - DI는 객체지향 프로그래밍 스타일
    - DI를 위해 컨테이너가 반드시 필요한 것은 아님
    - DI 컨테이너나 프레임워크는 DI를 편하게 적용하도록 도움을 줄 뿐, 컨테이너가 DI를 가능하게 해주는 것은 아님
- 침투적 (invasive) 기술
    - 기술을 적용했을 때 애플리케이션 코드에 기술 관련 API가 등장하거나 특정 인터페이스나 클래스를 사용하도록 강제하는 기술
    - 침투적 기술을 사용 시, 애플리케이션 코드가 해당 기술에 종속되는 결과를 가져옴
- 비침투적 (noninvasive) 기술
    - 애플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 적용이 가능
    - 기술에 종속적이지 않은 순수한 코드를 유지할 수 있게 해줌
    - 스프링은 비침투적인 기술의 대표적인 예, 이로 인해 스프링 컨테이너 없는 DI 테스트도 가능
- DI가 적용된 코드는 테스트에서도 다양한 방식으로 활용할 수 있을만큼 유연
- 어디에 DI를 적요할지 고민되는 경우, 효과적인 테스트를 만들기 위해서는 어떤 필요가 있을지를 생각해보면 도움이 됨
- 두 개의 모듈이 강하게 결합되어 있어 DI가 불가능한 구조로 만든 경우
    - 테스트할 때 불편해지거나, 자동화된 테스트가 아예 불가능한지 의심 필요
- **테스트하기 좋은 코드가 좋은 코드일 가능성이 높다**
- DI를 이용한 테스트 방법 선택
    - 항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려
        - 위 방법이 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결
        - 테스트를 위해 필요한 오브젝트의 생성과 초기화가 단순하다면 이 방법을 먼저 고려
    - 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트해야 할 경우
        - 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리
        - 테스트에서 애플리케이션 컨텍스트를 사용하는 경우, 테스트 전용 설정파일을 따로 만들어서 사용하는 편이 좋음
        - 보통 개발환경과 테스트환경, 운영환경이 차이가 있기 떄문에 각각 다른 설정파일을 만들어 사용하는 경우가 일반적
        - 개발자가 테스트할 떄는 개발환경에 맞춰서 만든 설정파일을 사용
    - 테스트 설정을 따로 만들었다고 하더라도 때로는 예외적인 의존관계를 강제로 구성해서 테스트 해야 할 경우
        - 컨텍스트에서 DI 받은 오브젝트에 다시 테스트 코드로 수종 DI 해서 테스트하는 방법을 사용
        - 테스트 메소드나 클레스에 `@DirtiesContext` 붙여야 함
    
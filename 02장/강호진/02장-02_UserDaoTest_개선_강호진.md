# 2장 테스트

## 2.2 UserDaoTest 개선

### 2.2.1 테스트 검증의 자동화

- 모든 테스트는 성공과 실패의 두 가지 결과를 가질 수 있음
    - 테스트 에러
        - 테스트의 실패는 테스트가 진행되는 동안에 에러가 발생해서 실패하는 경우
        - 테스트 중에 에러가 발생하는 것은 쉽게 확인 가능, 콘솔에 에러 메시지와 긴 호출 스택 정보가 출력
    - 테스트 실패
        - 테스트 작업중에 에러가 발생하진 않았지만, 그 결과가 기대한 것과 다르게 나오는 경우
        - 테스트 실패는 별도의 확인 작업과 그 결과가 있어야만 알 수 있음
- 코드의 동작에 어떤 영향을 미칠 수 있는 어떤 변화라도 생기면 언제든 다시 실행해볼 수 있음
- **테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것** - 켄트 백
- 만들어진 코드의 기능을 모두 점검할 수 있는 포괄적인 테스트(comprehensive test)를 만드는 경우
    - 개발한 애플리케이션이 이후에 어떤 과감한 수정을 하고 나서도 테스트를 모두 돌려보고 안심이 가능
    - 테스트를 통해 그 변경에 영향을 받는 부분이 정확히 확인된다면 빠르게 조치를 취할 수 있음
- 빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드로 된 자동화된 테스트를 만들어두는 것이 좋은 방법

### 2.2.2 테스트의 효율적인 수행과 결과 관리

- main() 메소드 대신 아래의 기능을 가진 테스트 지원도구와 그에 맞는 테스트 진행 방법이 필요
    - 일정한 패턴을 가진 테스트를 만들 수 있음
    - 많은 테스트를 간단히 실행시킬 수 있음
    - 테스트 결과를 종합해서 볼 수 있음
    - 테스트가 실패한 곳을 빠르게 찾을 수 있는 기능을 갖춤
- JUnit는 자바 테스팅 프레임워크
    - 프레임워크는 개발자가 만든 클래스에 대한 제어 권한은 넘겨받아서 주도적으로 애플리케이션의 흐름을 제어
    - 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행
    - 프레임워크에서 동작하는 코드는 main() 메소드도 필요 없고, 오브젝트를 만들어 실행시키는 코드를 만들 필요도 없음
- JUnit 프레임워크가 요구하는 조건 두 가지
    - 메소드가 `public`으로 선언돼야 함, JUnit 5 부터는 `public`이라고 선언하지 않아도 가능
    - 메소드에 `@Test`라는 애노테이션을 붙여주는 것
- `assertThat()` 메소드의 첫 번째 파라미터의 값을 뒤에서 나오는 매처(matcher)라고 불리는 조건으로 비교
    - 일치하면 다음으로 넘어가고 아니면 실패하도록 만듦
    - `is()` 매처의 일종으로 `equals()`로 비교해주는 기능을 가짐
- JUnit은 예외가 발생하거나 `assertThat()`에서 실패하지 않고 테스트 메소드의 실행이 완료되면 테스트가 성공했다고 인식
    - JUnit이 테스트를 실행하고 나면 테스트 결과를 다양한 방법으로 알려 줌
    - 테스트가 실패하면 OK 대신 FAILURES!! 라는 내용이 출력
    - 총 수행한 테스트 중에서 몇 개의 테스트가 실패했는지 보여줌
    - 함께 출력된 호출 스택을 살펴보면 실패한 원인이 무엇이고 테스트 코드에서 검증에 실패한 위치는 어디인지도 확인 가능
    - 테스트 수행 중에 일반 예외가 발생한 경우에도 마찬가지로 테스트 수행은 중단되고 테스트는 실패함
- JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit 프레임워크를 시작해줘야 함
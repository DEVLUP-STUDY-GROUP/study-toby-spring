# 3장 템플릿

## 3.6 스프링의 JdbcTemplate

### 3.6.0 들어가기

- 스프링은 JDBC를 이용하는 DAO에서 사용할 수 있도록 준비된 다양한 템플릿과 콜백을 제공
- 거의 모든 종류의 JDBC 코드에 사용 가능한 템플릿과 콜백을 제공
    - 자주 사용되는 패턴을 가진 콜백은 다시 템플릿에 결합시켜서 간단한 메소드 호출만으로 사용 가능하도록 만들어짐
    - 템플릿/콜백 방식의 기술을 사용하고 있는지도 모르고 쓸 수 있을 정도로 편리

### 3.6.1 update()

- `deleteAll()`에 처음 적용했던 콜백은 StatementStrategy 인터페이스의 makePreparedStatement() 메소드
    - JdbcTemplate의 콜백은 PreparedStatementCreator 인터페이스의 createPreparedStatement()
    - 템플릿으로부터 Connection을 제공받아 PreparedStatement을 만들어 돌려준다는 면에서 구조는 동일
    - PreparedStatementCreator 타입의 콜백을 받아서 사용하는 JdbcTemplate의 템플릿 메소드는 update()

### 3.6.2 queryForInt()

- getCount()는 SQL 쿼리를 실행하고 ResultSet을 통해 결과 값을 가져오는 코드
- 사용 가능한 템플릿은 PreparedStatementCreator 콜백과 ResultSetExtractor 콜백을 파라미터로 받는 query() 메소드
    - 첫 번째 PreparedStatementCreator 콜백은 템플릿으로부터 Connection을 받고 PreparedStatement를 돌려줌
    - 두 번째 ResultSetExtractor는 템플릿으로 ResultSet을 받고 거기서 추출한 결과를 돌려줌
- SQL의 실행 결과가 하나의 정수 값이 되는 경우 자주 볼 수 있음, 클라이언트에서 콜백을 템플릿 안으로 옮겨 재활용 가능
- JdbcTemplate은 이런 기능을 가진 콜백을 내장하고 있는 queryForInt()라는 메소드를 제공
- JdbcTemplate은 스프링이 제공하는 클래스이지만 DI 컨테이너를 굳이 필요로 하지 않음
- 직접 JdbcTemplate 오브젝트를 생성하고 필요한 DataSource를 전달하면 JdbcTemplate의 모든 기능을 자유롭게 활용 가능

### 3.6.3 queryForObject()

- SQL은 바인딩이 필요한 치환자를 갖고 있음
- ResultSetExtractor와 RowMapper 모두 템플릿으로부터 ResultSet을 전달받고, 필요한 정보를 추출해서 리턴하는 방식으로 동작
- ResultSetExtractor와 RowMapper의 차이점
    - ResultSetExtractor는 ResultSet을 한번 전달받아 알아서 추출 작업을 모두 진행하고 최종 결과만 리턴
    - RowMapper는 ResultSet의 로우 하나를 매핑하기 위해 사용되기 때문에 여러 번 호출 가능
- queryForObject()는 SQL 실행 시, 한 개의 로우만 얻을 것이라고 기대
- RowMapper가 호출되는 시점에서 ResultSet은 첫 번째 로우를 가리키고 있으므로 rs.next()를 호출할 필요 없음
- queryForObject()는 SQL을 실행해서 받은 로우의 개수가 하나가 아니라면 예외를 던지도록 만들어짐
    - EmptyResultDataAceessException

### 3.6.4 query()

- 불필요하게 테스트를 복잡하게 하는 건 별로 좋은 습관은 아니지만, 성의없이 결과 한 가지만 검사해보는 것도 위험
    - 최소한 두 가지 이상의 테스트 조건에 대해 기대한 결과를 확인해봐야 함
- @Test나 @Before 등의 애너테이션이 붙지 않는 메소드에 테스트 코드에서 반복적인 코드를 담아두고 재사용하는 건 좋은 습관
- queryForObject()는 쿼리의 결과가 로우 하나일 때 사용, query()는 여러 개의 로우가 결과로 나오는 일반적인 경우에 사용
- 첫 번째 파라미터에는 실행할 SQL 쿼리, 바인딩할 라미터가 있따면 두번째 파라미터에 추가, 파라미터가 없다면 생략 가능
- query() 템플릿은 SQL을 실행해서 얻은 ResultSet의 모든 로우를 열람하면서 로우마다 RowMapper 콜백을 호출
- 성공적인 테스트 결과를 보면 빨리 다음 기능으로 넘어가고 싶겠지만 너무 서두르는 것은 좋지 않음
    - 항상 꼼꼼하게 빠진 것은 없는지 더 개선할 부분은 없는지 한 번쯤 생각
    - 네거티브 테스트라고 불리는, 예외 상황에 대한 테스트는 항상 빼먹기 쉬움
- 개발자들이 예외적인 상황에 대한 검증을 잘 안 하려는 습관이 있음
- 미리 예외상황에 대한 일관성 있는 기준을 정해두고 이를 테스트로 만들어 검증
- "테스트를 작성할 때 항상 네거티브 테스트부터 만드는 습관이 있음" - 로드 존슨
- 정상적인 조건의 테스트부터 만들면 테스트가 성공하는 것을 보고 쉽게 만족해서 예외적인 상황은 빼먹고 넘어가기가 쉬움
- 예외상황에 대한 테스트를 자꾸 빼먹는 개발자가면 의도적으로 예외적인 조건에 대해 먼저 테스트를 만드는 습관을 들이는 것도 좋음
- getAll() 메소드의 내부 구조를 아는 개발자 입장에서도 JdbcTemplate의 query() 메소드에 대한 학습 테스트로서 의미가 있음
    - query()는 겨로가가 없을 때 빈 리스트를 리턴하는지 한 번쯤은 직접 확인 필요

### 3.6.5 재사용 가능한 콜백의 분리

- UserDao 코드의 양이 줄었을 뿐 아니라 각 메소드의 기능을 파악하기도 쉽게 되어 있음
- 핵심적인 SQL 문장과 파라미터, 생성되는 결과의 타입정보만 남기고 모든 판에 박힌 로우레벨 중복 코드는 깔끔하게 제거됨
- DataSource 인스턴스 변수는 제거, JdbcTemplate을 생성하면서 직접 DI 하기 위해서 필요한 인자로만 남겨둠
- 두 개 이상의 RowMapper가 있는데 모두 정확하게 수정해주지 않으면 문제 발생
    - User용 RowMapper 콜백을 메소드에서 분리해 중복을 없애고 재사용되게 만듦
    - RowMapper 콜백 오브젝트에는 상태 정보가 없으므로 하나의 콜백 오브젝트를 멀티 스레드에서 동시에 사용해도 문제가 되지 않음
- UserDao에는 User 정보를 DB에 넣거나 가져오거나 조작하는 방법에 대한 핵심적인 로직만 담김
- User라는 자바 오브젝트와 User 테이블 사이에 어떻게 정보를 주고 받을지
    - DB와 커뮤니케이션하기 위한 SQL문장이 어떤것인지에 대한 최적화된 코드를 가짐
- 사용할 테이블과 필드정보가 바뀌면 USerDao의 거의 모든 코드가 함께 바뀜 → 응집도가 높음
- JDBC API를 사용하는 방식, 예외처리, 리소스 반납, DB 연결을 어떻게 가져올지에 관한 책임과 관심은 모두 JdbcTemplate에 있음
    - 변경이 일어난다고 해도 UserDao 코드에는 아무런 영향을 주지 않음 → 책임이 다른 코드와는 낮은 결합도를 유지
    - JdbcTemplate이라는 템플릿 클래스를 직접 이용한다는 면에서 특정 템플릿/콜백 구현에 대한 강한 결합을 가짐
- 더 낮은 결합도를 유지하고 싶은 경우
    - JdbcTemplate을 독립적인 빈으로 등록하고 JdbcTemplate이 구현하고 있는 JdbcOperations 인터페이스를 통해 DI 받아 사용
- 스프링에는 JdbcTemplate 외에도 십여가지 템플릿/콜백 패턴을 적용한 API가 존재
- 클래스 이름이 Template으로 끝나거나 인터페이스 이름이 Callback으로 끝난다면 템플릿/콜백이 적용된 것이라고 보면 됨

### 3.7 정리

- JDBC와 같은 예외가 발생할 가능성이 있으며 공유 리소스의 반환이 필요한 코드는 반드시 `try/catch/finally` 블록으로 관리해야 한다.
- 일정한 작업 흐름이 반복되면서 그중 일부 기능만 바뀌는 코드가 존재한다면 전략 패턴을 적용한다. 바뀌지 않는 부분은 컨텍스트로, 바뀌는 부분은 전략으로 만들고 인터페이스를 통해 유연하게 전략을 변경할 수 있도록 구성한다.
- 같은 애플리케이션 안에서 여러 가지 종류의 전략을 다이내믹하게 구성하고 사용해야 한다면 컨텍스트를 이용하는 클라이언트 메소드에서 직접 전략을 정의하고 제공하게 만든다.
- 클라이언트 메소드 안에 익명 내부 클래스를 사용해서 전략 오브젝트를 구현하면 코드도 간결해지고 메소드의 정보를 직접 사용할 수 있어서 편리하다.
- 컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면 클래스를 분리해서 공유하도 록 만든다.
- 컨텍스트는 별도의 빈으로 등록해서 DI 받거나 클라이언트 클래스에서 직접 생성해서 사용 한다. 클래스 내부에서 컨텍스트를 사용할 때 컨텍스트가 의존하는 외부의 오브젝트가 있다 면 코드를 이용해서 직접 DI 해줄 수 있다.
- 단일 전략 메소드를 갖는 전략 패턴이면서 익명 내부 클래스를 사용해서 매번 전략을 새로 만들어 사용하고, 컨텍스트 호출과 동시에 전략 DI를 수행하는 방식을 템플릿/콜백 패턴이 라고 한다.
- 콜백의 코드에도 일정한 패턴이 반복된다면 콜백을 템플릿에 넣고 재활용하는 것이 편리하다.
- 템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스를 이용한다.
- 스프링은 JDBC 코드 작성을 위해 Jdbc TempLate을 기반으로 하는 다양한 템플릿과 콜백을 제공한다
- 템플릿은 한 번에 하나 이상의 콜백을 사용할 수도 있고, 하나의 콜백을 여러 번 호출할 수 도 있다.
- 템플릿/콜백을 설계할 때는 템플릿과 콜백 사이에 주고받는 정보에 관심을 둬야 한다.

- 템플릿/콜백은 스프링이 객체지향 설계와 프로그래밍에 얼마나 가치를 두고 있는지를 잘 보여주는 예
- 스프링이 제공하는 템플릿/콜백을 잘 사용해야 하는 것은 물론이며 직접 템플릿/콜백을 만들어 활용할 수도 있어야 함